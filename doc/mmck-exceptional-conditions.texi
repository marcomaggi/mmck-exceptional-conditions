\input texinfo.tex
@c %**start of header
@setfilename mmck-exceptional-conditions.info
@settitle @sc{mmck} Exceptional Conditions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Exceptional Conditions for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Exceptional Conditions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-exceptional-conditions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                exceptional-conditions

@set PackageAutoconfPrefix      MMCK_EXCEPTIONAL_CONDITIONS
@set PackagePkgconfigModule     mmck-exceptional-conditions

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional--conditions.  @chicken{} is a Scheme--to--C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-exceptional-conditions: (mmck-exceptional-conditions).
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* exceptions::                  Handling exceptional-conditions.
* conditions::                  Exceptional-condition objects.
* errors::                      Raising errors.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck exceptional-conditions}, library
@cindex Library @library{mmck exceptional-conditions}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional conditions.  @chicken{} is a Scheme-to-C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  This package depends upon the @chicken{} egg
@code{matchable}.  To run the tests distributed with the source code: this package depends upon the
package @mmck{} Checks.

@value{PACKAGE} defines an @api{} derived from the one specified in the ``Revised^6 Report on the
Algorithmic Language Scheme'' (@rnrs{6}); this document itself contains revised sections of the
original @rnrs{6} document.  While similar, the two @api{}s are not equal; however, this package
should make it easier to port @rnrs{6} code to @chicken.

The package installs the library @library{mmck exceptional-conditions} along with its import
library; this library has naming conflicts with the module @library{chicken condition} bundled with
@chicken{}.  To require the library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck exceptional-conditions))

(module (my-module)
    ()
  (import (scheme)
    (mmck exceptional-conditions))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node exceptions
@chapter Handling exceptional--conditions


@cindex Handling exceptional--conditions
@cindex Raising exceptional--conditions
@cindex Exceptional--conditions, raising
@cindex Exceptional--conditions, handling

@menu
* exceptions reexports::        Syntactic bindings reexported from
                                @library{chicken condition}.
@end menu

@c page
@node exceptions reexports
@section Syntactic bindings reexported from @library{chicken condition}


The following syntactic bindings are reexported by @library{mmck exceptional-conditions} from
@library{chicken condition}.


@defun with-exception-handler @var{handler} @var{thunk}
Install the procedure @var{handler} as current exception handler in the dynamic environment, then
invoke @var{thunk}.  When @var{thunk} returns successfully: return the values returned by
@var{thunk}.

@strong{NOTE} The @var{handler} must @strong{not} return locally: instead it must escape to a
different continuation.  A normal return will cause an exception to be raised in the same dynamic
environment, so entering an infinite loop.

Usage examples:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape 456))
        (lambda ()
          123))))
@result{} 123

(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape (list (condition-who E)
                          (condition-message E)
                          (condition-irritants E))))
        (lambda ()
          (error 'me "the message" 1 2 3)))))
@result{} (me "the message" (1 2 3))
@end lisp
@end defun

@c page
@node conditions
@chapter Exceptional--condition object


@cindex Exceptional--condition objects
@cindex Exceptional--condition object--types
@cindex Condition object--types


This section describes an @api{} for creating and inspecting condition types and values.  A
condition value encapsulates information about an exceptional situation; the @api{} also defines a
number of basic condition types.  This @api{} and this documentation section are derived from the
ones defined by @rnrs{6}, but the underlying condition objects representation is the one built--in
into @chicken{} and defined by the module @library{chicken condition}.

Scheme conditions provide two mechanisms to enable communication about an exceptional situation:
subtyping among condition types allows handling code to determine the general nature of an exception
even though it does not anticipate its exact nature, and compound conditions allow an exceptional
situation to be described in multiple ways.

@menu
* conditions objects::          Condition objects.
* conditions types::            Predefined condition types.
@end menu

@c page
@node conditions objects
@section Condition objects


Conceptually, there are two different kinds of condition objects: @emph{simple conditions} and
@emph{compound conditions}.  An object that is either a simple condition or a compound condition is
simply a @emph{condition}.  Compound conditions form a type disjoint from the base types.  A simple
condition describes a single aspect of an exceptional situation.  A compound condition represents
multiple aspects of an exceptional situation as a list of simple conditions, its @emph{components}.
Most of the operations described in this section treat a simple condition identically to a compound
condition with itself as its own sole component.


@deftp {Condition Kind} {&condition}
Simple conditions are formal subtypes of the @condition{condition} kind.  The @condition{condition}
kind has no fields.
@end deftp


@defun condition @vari{condition} @dots{}
Return a condition object with the components of the @var{condition}s as its components, in the same
order, i.e., with the components of @vari{condition} appearing first in the same order as in
@vari{condition}, then with the components of @varii{condition}, and so on.  The returned condition
is compound if the total number of components is zero or greater than one.  Otherwise, it may be
compound or simple.
@end defun


@defun simple-conditions @var{condition}
The @func{simple-conditions} procedure returns a list of the components of @var{condition}, in the
same order as they appeared in the construction of @var{condition}.  The returned list is immutable.
If the returned list is modified, the effect on @var{condition} is unspecified.

@quotation
@strong{NOTE} Because @func{condition} decomposes its arguments into simple conditions,
@func{simple-conditions} always returns a ``flattened'' list of simple conditions.
@end quotation
@end defun


@defun {condition?} @var{obj}
Return @true{} if @var{obj} is a (simple or compound) condition, otherwise return @false{}.
@end defun


@defun condition-kinds @var{obj}
The argument @var{obj} must be a condition object, either simple or compound.  Return a list of
symbols representing the condition kinds in @var{obj}; the list may contain duplicates.

@lisp
(condition-kinds
  (condition (make-error)
             (make-who-condition 'me)
             (make-message-condition "the message")
             (make-irritants-condition '(1 2 3))))
@result{} (&error &serious &condition
    &who &condition
    &message &condition
    &irritants &condition)
@end lisp
@end defun


@deffn Syntax define-condition-type @qvar{condition-kind} @qvar{supertype} @qvar{constructor} @qvar{predicate} @qvari{field-spec} @dots{}
@qvar{condition-kind}, @qvar{supertype}, @qvar{constructor}, and @qvar{predicate} must all be
identifiers.  Each @qvar{field-spec} must be of the form

@example
(@qvar{field} @qvar{accessor})
@end example

@noindent
where both @qvar{field} and @qvar{accessor} must be identifiers.

The @func{define-condition-type} form expands into a group of definitions for the constructor,
predicate and field accessors for a new condition kind @qvar{condition-kind}.  The identifiers will
be bound as follows:

@itemize
@item
@qvar{constructor} is bound to a default constructor for the kind: it accepts one argument for each
of the record kind's complete set of fields (including parent kinds, with the fields of the parent
coming before those of the extension in the arguments) and returns a condition object initialised to
those arguments.  The returned object is a compound that contains the kind @qvar{condition-kind},
the kind @qvar{supertype} and all the parent kinds of @qvar{supertype}.

@item
@qvar{predicate} is bound to a predicate that identifies conditions of type @qvar{condition-kind} or
any of its subtypes.

@item
Each @qvar{accessor} is bound to a procedure that extracts the corresponding field from a condition
of type @qvar{condition-kind}.  The fields of a condition kind are its properties as defined by the
module @library{chicken condition}.
@end itemize
@end deffn


Some usage examples:

@lisp
(define-condition-type &c &condition
  make-c c?
  (x c-x))

(define-condition-type &c1 &c
  make-c1 c1?
  (a c1-a))

(define-condition-type &c2 &c
  make-c2 c2?
  (b c2-b))
@end lisp

@lisp
(define v1 (make-c1 "V1" "a1"))

(c? v1)        @result{} #t
(c1? v1)       @result{} #t
(c2? v1)       @result{} #f
(c-x v1)       @result{} "V1"
(c1-a v1)      @result{} "a1"
@end lisp

@lisp
(define v2 (make-c2 "V2" "b2"))

(c? v2)        @result{} #t
(c1? v2)       @result{} #f
(c2? v2)       @result{} #t
(c-x v2)       @result{} "V2"
(c2-b v2)      @result{} "b2"
@end lisp

@lisp
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        @result{} #t
(c1? v3)       @result{} #t
(c2? v3)       @result{} #t
(c-x v3)       @result{} "V3/1"
(c1-a v3)      @result{} "a3"
(c2-b v3)      @result{} "b3"
@end lisp

@lisp
(define v4 (condition v1 v2))

(c? v4)        @result{} #t
(c1? v4)       @result{} #t
(c2? v4)       @result{} #t
(c-x v4)       @result{} "V1"
(c1-a v4)      @result{} "a1"
(c2-b v4)      @result{} "b2"
@end lisp

@lisp
(define v5 (condition v2 v3))

(c? v5)        @result{} #t
(c1? v5)       @result{} #t
(c2? v5)       @result{} #t
(c-x v5)       @result{} "V2"
(c1-a v5)      @result{} "a3"
(c2-b v5)      @result{} "b2"
@end lisp

@c page
@node conditions types
@section Predefined condition types


Hierarchy of predefined condition types:

@example
&condition
   |
   +-----> &warning
   |
   +-----> &message
   |       &irritants
   |       &who
   |
   +-----> &serious
              |
              +-----> &error
              |
              +-----> &violation
                         |
                         +-----> &assertion
                         |
                         +-----> &non-continuable
                         |
                         +-----> &implementation-restriction
                         |
                         +-----> &lexical
                         |
                         +-----> &syntax
                         |
                          -----> &undefined
@end example


@tindex &message
@deffn {Condition Kind} {&message}
@deffnx Function make-message-condition @var{message}
@deffnx Function message-condition? @var{obj}
@deffnx Function condition-message @var{condition}
This condition type could be defined by:

@example
(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))
@end example

It carries a message further describing the nature of the condition to
humans.
@end deffn


@tindex &warning
@deffn {Condition Kind} {&warning}
@deffnx Function make-warning
@deffnx Function warning? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &warning &condition
  make-warning warning?)
@end example

This type describes conditions that do not, in principle, prohibit
immediate continued execution of the program, but may interfere with the
program's execution later.
@end deffn


@tindex &serious
@deffn {Condition Kind} {&serious}
@deffnx Function make-serious-condition
@deffnx Function serious-condition? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &serious &condition
  make-serious-condition serious-condition?)
@end example

This type describes conditions serious enough that they cannot safely be
ignored.  This condition type is primarily intended as a supertype of
other condition types.
@end deffn


@tindex &error
@deffn {Condition Kind} {&error}
@deffnx Function make-error
@deffnx Function error? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &error &serious
  make-error error?)
@end example

This type describes errors, typically caused by something that has gone
wrong in the interaction of the program with the external world or the
user.
@end deffn


@tindex &violation
@deffn {Condition Kind} {&violation}
@deffnx Function make-violation
@deffnx Function violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &violation &serious
  make-violation violation?)
@end example

This type describes violations of the language standard or a library
standard, typically caused by a programming error.
@end deffn


@tindex &assertion
@deffn {Condition Kind} {&assertion}
@deffnx Function make-assertion-violation
@deffnx Function assertion-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)
@end example

This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
@end deffn


@tindex &irritants
@deffn {Condition Kind} {&irritants}
@deffnx Function make-irritants-condition @var{irritants}
@deffnx Function irritants-condition? @var{obj}
@deffnx Function condition-irritants @var{condition}
This condition type could be defined by:

@example
(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))
@end example

@var{irritants} should be a list of objects.  This condition provides
additional information about a condition, typically the argument list of
a procedure that detected an exception.  Conditions of this type are
created by the procedures @func{error} and @func{assertion-violation}.
@end deffn


@tindex &who
@deffn {Condition Kind} {&who}
@deffnx Function make-who-condition @var{who}
@deffnx Function who-condition? @var{obj}
@deffnx Function condition-who @var{condition}
This condition type could be defined by:

@example
(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))
@end example

@var{who} should be a symbol or string identifying the entity reporting the exception.  Conditions
of this type are created by the @func{error} and @func{assertion-violation} procedures, and the
@func{syntax-violation} procedure.
@end deffn


@tindex &non-continuable
@deffn {Condition Kind} {&non-continuable}
@deffnx Function make-non-continuable-violation
@deffnx Function non-continuable-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)
@end example

This type indicates that an exception handler invoked via @func{raise}
has returned.
@end deffn


@tindex &implementation-restriction
@deffn {Condition Kind} {&implementation-restriction}
@deffnx Function make-implementation-restriction-violation
@deffnx Function implementation-restriction-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &implementation-restriction
    &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)
@end example

This type describes a violation of an implementation restriction allowed
by the specification, such as the absence of representations for NaNs
and infinities.
@end deffn


@tindex &lexical
@deffn {Condition Kind} {&lexical}
@deffnx Function make-lexical-violation
@deffnx Function lexical-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)
@end example

This type describes syntax violations at the level of the datum syntax.
@end deffn


@tindex &syntax
@deffn {Condition Kind} {&syntax}
@deffnx Function make-syntax-violation @var{form} @var{subform}
@deffnx Function syntax-violation? @var{obj}
@deffnx Function syntax-violation-form @var{condition}
@deffnx Function syntax-violation-subform @var{condition}
This condition type could be defined by:

@example
(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))
@end example

This type describes syntax violations.  @var{form} should be the
erroneous syntax object or a datum representing the code of the
erroneous form.  @var{subform} should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be @false{} to indicate the absence of more precise
information.
@end deffn


@tindex &undefined
@deffn {Condition Kind} {&undefined}
@deffnx Function make-undefined-violation
@deffnx Function undefined-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)
@end example

This type describes unbound identifiers in the program.
@end deffn

@c page
@node errors
@chapter Raising errors


@defun error @var{who} @var{message} @vari{irritant} @dots{}
@defunx assertion-violation @var{who} @var{message} @vari{irritant} @dots{}
@var{who} must be a string or a symbol or @false{}.  @var{message} must be a string.  The
@var{irritant}s are arbitrary objects.

These procedures raise a non--continuable exception.  The @func{error} procedure should be called
when an error has occurred, typically caused by something that has gone wrong in the interaction of
the program with the external world or the user.  The @func{assertion-violation} procedure should be
called when an invalid call to a procedure was made, either passing an invalid number of arguments,
or passing an argument that it is not specified to handle.

The @var{who} argument should describe the procedure or operation that detected the exception.  The
@var{message} argument should describe the exceptional situation.  The @var{irritant}s should be the
arguments to the operation that detected the violation.

The condition object provided with the exception has the following condition types:

@itemize
@item
If @var{who} is not @false{}, the condition has condition type @condition{who}, with @var{who} as
the value of its field.  In that case, @var{who} should be the name of the procedure or entity that
detected the exception.  If it is @false{}, the condition does not have condition type
@condition{who}.

@item
The condition has condition type @condition{message}, with @var{message} as
the value of its field.

@item
The condition has condition type @condition{irritants}, and its field has as
its value a list of the @var{irritant}s.
@end itemize

Moreover, the condition created by @func{error} has condition type
@condition{error}, and the condition created by @func{assertion-violation}
has condition type @condition{assertion}.

@example
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5)         @result{} 120
(fac 4.5)       @error{} exception &assertion
(fac -3)        @error{} exception &assertion
@end example
@end defun


@deffn Syntax assert @meta{expression}
An @func{assert} form is evaluated by evaluating @meta{expression}.  If @meta{expression} returns a
true value, that value is returned from the @func{assert} expression.  If @meta{expression} returns
@false{}, an exception with condition types @condition{assertion} and @condition{message} is raised.
The message provided in the condition object is implementation--dependent.
@end deffn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

The original version of the @rnrs{6} document, and its errata, are available at:

@center @url{http://www.r6rs.org/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
