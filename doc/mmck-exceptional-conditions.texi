\input texinfo.tex
@c %**start of header
@setfilename mmck-exceptional-conditions.info
@settitle @sc{mmck} Exceptional Conditions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Exceptional Conditions for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Exceptional Conditions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-exceptional-conditions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                exceptional-conditions

@set PackageAutoconfPrefix      MMCK_EXCEPTIONAL_CONDITIONS
@set PackagePkgconfigModule     mmck-exceptional-conditions

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional--conditions.  @chicken{} is a Scheme--to--C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-exceptional-conditions: (mmck-exceptional-conditions).
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* conditions::                  Exceptional-condition objects.
* exceptions::                  Handling exceptional-conditions.
* syntaxes::                    Syntactic extensions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck exceptional-conditions}, library
@cindex Library @library{mmck exceptional-conditions}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional conditions.  @chicken{} is a Scheme-to-C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  This package depends upon the @chicken{} egg
@code{matchable}.  To run the tests distributed with the source code: this package depends upon the
package @mmck{} Checks.

@value{PACKAGE} defines an @api{} derived from the one specified in the ``Revised^6 Report on the
Algorithmic Language Scheme'' (@rnrs{6}); this document itself contains revised sections of the
original @rnrs{6} document.  While similar, the two @api{}s are not equal; however, this package
should make it easier to port @rnrs{6} code to @chicken.

The package installs the library @library{mmck exceptional-conditions} along with its import
library; this library has naming conflicts with the module @library{chicken condition} bundled with
@chicken{}.  To require the library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck exceptional-conditions))

(module (my-module)
    ()
  (import (scheme)
    (mmck exceptional-conditions))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node conditions
@chapter Exceptional--condition objects


@cindex Exceptional--condition objects
@cindex Exceptional--condition object--types
@cindex Condition object--types


This section describes an @api{} for creating and inspecting condition types and values.  A
condition value encapsulates information about an exceptional situation; the @api{} also defines a
number of basic condition types.  This @api{} and this documentation section are derived from the
ones defined by @rnrs{6}, but the underlying condition objects representation is the one built--in
into @chicken{} and defined by the module @library{chicken condition}.

Scheme conditions provide two mechanisms to enable communication about an exceptional situation:
subtyping among condition types allows handling code to determine the general nature of an exception
even though it does not anticipate its exact nature, and compound conditions allow an exceptional
situation to be described in multiple ways.

@menu
* conditions objects::          Condition objects.
* conditions types r6rs::       Predefined condition types compatible with @rnrs{6}.
* conditions types ext::        Extended predefined condition types.
@end menu

@c page
@node conditions objects
@section Condition objects


Conceptually, there are two different kinds of condition objects: @emph{simple conditions} and
@emph{compound conditions}.  An object that is either a simple condition or a compound condition is
simply a @emph{condition}.  Compound conditions form a type disjoint from the base types.  A simple
condition describes a single aspect of an exceptional situation.  A compound condition represents
multiple aspects of an exceptional situation as a list of simple conditions, its @emph{components}.
Most of the operations described in this section treat a simple condition identically to a compound
condition with itself as its own sole component.


@deftp {Condition Kind} {&condition}
Simple conditions are formal subtypes of the @condition{condition} kind.  The @condition{condition}
kind has no fields.
@end deftp


@defun condition @vari{condition} @dots{}
Return a condition object with the components of the @var{condition}s as its components, in the same
order, i.e., with the components of @vari{condition} appearing first in the same order as in
@vari{condition}, then with the components of @varii{condition}, and so on.  The returned condition
is compound if the total number of components is zero or greater than one.  Otherwise, it may be
compound or simple.
@end defun


@defun simple-conditions @var{condition}
The @func{simple-conditions} procedure returns a list of the components of @var{condition}, in the
same order as they appeared in the construction of @var{condition}.  The returned list is immutable.
If the returned list is modified, the effect on @var{condition} is unspecified.

@quotation
@strong{NOTE} Because @func{condition} decomposes its arguments into simple conditions,
@func{simple-conditions} always returns a ``flattened'' list of simple conditions.
@end quotation
@end defun


@defun {condition?} @var{obj}
Return @true{} if @var{obj} is a (simple or compound) condition, otherwise return @false{}.
@end defun


@defun condition-kinds @var{obj}
The argument @var{obj} must be a condition object, either simple or compound.  Return a list of
symbols representing the condition kinds in @var{obj}; the list may contain duplicates.

@lisp
(condition-kinds
  (condition (make-error)
             (make-who-condition 'me)
             (make-message-condition "the message")
             (make-irritants-condition '(1 2 3))))
@result{} (&error &serious &condition
    &who &condition
    &message &condition
    &irritants &condition)
@end lisp
@end defun


@deffn Syntax define-condition-type @qvar{condition-kind} @qvar{supertype} @qvar{constructor} @qvar{predicate} @qvari{field-spec} @dots{}
@qvar{condition-kind}, @qvar{supertype}, @qvar{constructor}, and @qvar{predicate} must all be
identifiers.  Each @qvar{field-spec} must be of the form

@example
(@qvar{field} @qvar{accessor})
@end example

@noindent
where both @qvar{field} and @qvar{accessor} must be identifiers.

The @func{define-condition-type} form expands into a group of definitions for the constructor,
predicate and field accessors for a new condition kind @qvar{condition-kind}.  The identifiers will
be bound as follows:

@itemize
@item
@qvar{constructor} is bound to a default constructor for the kind: it accepts one argument for each
of the record kind's complete set of fields (including parent kinds, with the fields of the parent
coming before those of the extension in the arguments) and returns a condition object initialised to
those arguments.  The returned object is a compound that contains the kind @qvar{condition-kind},
the kind @qvar{supertype} and all the parent kinds of @qvar{supertype}.

@item
@qvar{predicate} is bound to a predicate that identifies conditions of type @qvar{condition-kind} or
any of its subtypes.

@item
Each @qvar{accessor} is bound to a procedure that extracts the corresponding field from a condition
of type @qvar{condition-kind}.  The fields of a condition kind are its properties as defined by the
module @library{chicken condition}.
@end itemize
@end deffn


Some usage examples:

@lisp
(define-condition-type &c &condition
  make-c c?
  (x c-x))

(define-condition-type &c1 &c
  make-c1 c1?
  (a c1-a))

(define-condition-type &c2 &c
  make-c2 c2?
  (b c2-b))
@end lisp

@lisp
(define v1 (make-c1 "V1" "a1"))

(c? v1)        @result{} #t
(c1? v1)       @result{} #t
(c2? v1)       @result{} #f
(c-x v1)       @result{} "V1"
(c1-a v1)      @result{} "a1"
@end lisp

@lisp
(define v2 (make-c2 "V2" "b2"))

(c? v2)        @result{} #t
(c1? v2)       @result{} #f
(c2? v2)       @result{} #t
(c-x v2)       @result{} "V2"
(c2-b v2)      @result{} "b2"
@end lisp

@lisp
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        @result{} #t
(c1? v3)       @result{} #t
(c2? v3)       @result{} #t
(c-x v3)       @result{} "V3/1"
(c1-a v3)      @result{} "a3"
(c2-b v3)      @result{} "b3"
@end lisp

@lisp
(define v4 (condition v1 v2))

(c? v4)        @result{} #t
(c1? v4)       @result{} #t
(c2? v4)       @result{} #t
(c-x v4)       @result{} "V1"
(c1-a v4)      @result{} "a1"
(c2-b v4)      @result{} "b2"
@end lisp

@lisp
(define v5 (condition v2 v3))

(c? v5)        @result{} #t
(c1? v5)       @result{} #t
(c2? v5)       @result{} #t
(c-x v5)       @result{} "V2"
(c1-a v5)      @result{} "a3"
(c2-b v5)      @result{} "b2"
@end lisp

@c page
@node conditions types r6rs
@section Predefined condition types compatible with @rnrs{6}


Hierarchy of predefined condition types:

@example
&condition
   |
   +-----> &warning
   |
   +-----> &message
   |       &irritants
   |       &who
   |
   +-----> &serious
              |
              +-----> &error
              |
              +-----> &violation
                         |
                         +-----> &assertion
                         |
                         +-----> &non-continuable
                         |
                         +-----> &implementation-restriction
                         |
                         +-----> &lexical
                         |
                         +-----> &syntax
                         |
                          -----> &undefined
@end example


@tindex &message
@deffn {Condition Kind} {&message}
@deffnx Function make-message-condition @var{message}
@deffnx Function message-condition? @var{obj}
@deffnx Function condition-message @var{condition}
This condition type could be defined by:

@lisp
(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))
@end lisp

It carries a message further describing the nature of the condition to
humans.
@end deffn


@tindex &warning
@deffn {Condition Kind} {&warning}
@deffnx Function make-warning
@deffnx Function warning? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &warning &condition
  make-warning warning?)
@end lisp

This type describes conditions that do not, in principle, prohibit
immediate continued execution of the program, but may interfere with the
program's execution later.
@end deffn


@tindex &serious
@deffn {Condition Kind} {&serious}
@deffnx Function make-serious-condition
@deffnx Function serious-condition? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &serious &condition
  make-serious-condition serious-condition?)
@end lisp

This type describes conditions serious enough that they cannot safely be
ignored.  This condition type is primarily intended as a supertype of
other condition types.
@end deffn


@tindex &error
@deffn {Condition Kind} {&error}
@deffnx Function make-error
@deffnx Function error? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &error &serious
  make-error error?)
@end lisp

This type describes errors, typically caused by something that has gone
wrong in the interaction of the program with the external world or the
user.
@end deffn


@tindex &violation
@deffn {Condition Kind} {&violation}
@deffnx Function make-violation
@deffnx Function violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &violation &serious
  make-violation violation?)
@end lisp

This type describes violations of the language standard or a library
standard, typically caused by a programming error.
@end deffn


@tindex &assertion
@deffn {Condition Kind} {&assertion}
@deffnx Function make-assertion-violation
@deffnx Function assertion-violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)
@end lisp

This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
@end deffn


@tindex &irritants
@deffn {Condition Kind} {&irritants}
@deffnx Function make-irritants-condition @var{irritants}
@deffnx Function irritants-condition? @var{obj}
@deffnx Function condition-irritants @var{condition}
This condition type could be defined by:

@lisp
(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))
@end lisp

@var{irritants} should be a list of objects.  This condition provides
additional information about a condition, typically the argument list of
a procedure that detected an exception.  Conditions of this type are
created by the procedures @func{error} and @func{assertion-violation}.
@end deffn


@tindex &who
@deffn {Condition Kind} {&who}
@deffnx Function make-who-condition @var{who}
@deffnx Function who-condition? @var{obj}
@deffnx Function condition-who @var{condition}
This condition type could be defined by:

@lisp
(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))
@end lisp

@var{who} should be a symbol or string identifying the entity reporting the exception.  Conditions
of this type are created by the @func{error} and @func{assertion-violation} procedures, and the
@func{syntax-violation} procedure.
@end deffn


@tindex &non-continuable
@deffn {Condition Kind} {&non-continuable}
@deffnx Function make-non-continuable-violation
@deffnx Function non-continuable-violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)
@end lisp

This type indicates that an exception handler invoked via @func{raise}
has returned.
@end deffn


@tindex &implementation-restriction
@deffn {Condition Kind} {&implementation-restriction}
@deffnx Function make-implementation-restriction-violation
@deffnx Function implementation-restriction-violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &implementation-restriction
    &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)
@end lisp

This type describes a violation of an implementation restriction allowed
by the specification, such as the absence of representations for NaNs
and infinities.
@end deffn


@tindex &lexical
@deffn {Condition Kind} {&lexical}
@deffnx Function make-lexical-violation
@deffnx Function lexical-violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)
@end lisp

This type describes syntax violations at the level of the datum syntax.
@end deffn


@tindex &syntax
@deffn {Condition Kind} {&syntax}
@deffnx Function make-syntax-violation @var{form} @var{subform}
@deffnx Function syntax-violation? @var{obj}
@deffnx Function syntax-violation-form @var{condition}
@deffnx Function syntax-violation-subform @var{condition}
This condition type could be defined by:

@lisp
(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))
@end lisp

This type describes syntax violations.  @var{form} should be the
erroneous syntax object or a datum representing the code of the
erroneous form.  @var{subform} should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be @false{} to indicate the absence of more precise
information.
@end deffn


@tindex &undefined
@deffn {Condition Kind} {&undefined}
@deffnx Function make-undefined-violation
@deffnx Function undefined-violation? @var{obj}
This condition type could be defined by:

@lisp
(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)
@end lisp

This type describes unbound identifiers in the program.
@end deffn

@c page
@node conditions types ext
@section Extended predefined condition types


@subsubheading Non--reinstatable condition objects


@anchor{&non-reinstatable}
@deftp {Condition Kind} @acondition{non-reinstatable}
Condition object type representing an attempt to reinstate a continuation in an invalid context.
This condition type could be defined by:

@lisp
(define-condition-type &non-reinstatable
    &violation
  make-non-reinstatable-violation
  non-reinstatable-violation?)
@end lisp
@end deftp


@defun make-non-reinstatable-violation
Build and return a new condition object of type @condition{non-reinstatable}.
@end defun


@defun non-reinstatable-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type @condition{non-reinstatable}; otherwise
return @false{}.
@end defun


@defun non-reinstatable-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object with components: @condition{message}, @condition{irritants},
@condition{non-reinstatable}.  In addition, if @var{who} is not @false{}: the raised condition
object has a component @condition{who}.
@end defun

@c page
@node exceptions
@chapter Handling exceptional--conditions


@cindex Handling exceptional--conditions
@cindex Raising exceptional--conditions
@cindex Exceptional--conditions, raising
@cindex Exceptional--conditions, handling


@value{PACKAGE} allows programs to deal with exceptional situations using two cooperating
facilities: The exception system for raising and handling exceptional situations, and the condition
system for describing these situations.

The exception system allows the program, when it detects an exceptional situation, to pass control
to an exception handler, and to dynamically establish such exception handlers.  Exception handlers
are always invoked with an object describing the exceptional situation.  @value{PACKAGE}'s condition
system provides a predefined taxonomy of such descriptive objects, as well as a facility for
extending the taxonomy, @ref{conditions, Exceptional--condition object}.

The facilities described in this section are built upon a custom exception handler that must be
installed before using any of them.  We can do this in a module with:

@lisp
(module (mine)
    ()
  (import (scheme)
          (mmck exceptional-condition))

  (current-exception-handler default-exception-handler)

  #| end of module |#)
@end lisp

@menu
* exceptions handling::         Exceptions handling.
* exceptions errors::           Raising errors.
* exceptions interop::          Interoperability with @chicken{}.
@end menu

@c page
@node exceptions handling
@section Exceptions handling


This section describes @value{PACKAGE}'s exception--handling and exception--raising constructs
provided by the @library{mmck exceptional-conditions} library.

Exception handlers are one--argument procedures that determine the action the program takes when an
exceptional situation is signalled.  The system implicitly maintains a current exception handler as
part of the dynamic environment of the program.

The program raises an exception by invoking the current exception handler, passing it an object
encapsulating information about the exception.  Any procedure accepting one argument may serve as an
exception handler and any object may be used to represent an exception.

When a program begins its execution, the predefined exception handler:

@itemize
@item
Handles all @condition{serious} conditions by interrupting execution, reporting that an exception
has been raised, and displaying information about the condition object that was provided on the
current value of @func{current-error-port}.  The handler then exits the process with exit status
@code{255}.

@item
Handles all @condition{warning} conditions by reporting that an exception has been raised, and
displaying information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then returns attempting to resume execution.

@item
Handles all the other exceptional conditions by reporting that an exception has been raised, and
displaying information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then returns attempting to resume execution.
@end itemize

When the handler returns:

@itemize
@item
If the exception was raised with @func{raise}, a new exception is raised in a dynamic environment in
which the exception handler interrupts execution, reports that an exception has been raised, and
displays information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then exits the process with exit status @code{255}.

@item
If the exception was raised with @func{raise-continuable}, execution continues with the continuation
of the call to @func{raise-continuable}.
@end itemize


@anchor{with-exception-handler}
@defun with-exception-handler @var{handler} @var{thunk}
The argument @var{handler} must be a procedure and should accept one argument.  The argument
@var{thunk} must be a procedure that accepts zero arguments.  The @func{with-exception-handler}
procedure returns the results of invoking @var{thunk}.  @var{handler} is installed as the current
exception handler for the dynamic extent (as determined by @func{dynamic-wind}) of the invocation of
@var{thunk}.
@end defun


@anchor{guard}
@deffn Syntax guard (@qvar{variable} @qvari{cond-clause} @qvarii{cond-clause} @dots{}) @qvaro{body} @qvar{body} @dots{}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @qvar{cond-clause} is as in the specification of the standard syntax @syntax{cond}.  @samp{=>}
and @samp{else} are matched as symbols.

Evaluating a @syntax{guard} form evaluates the @qvar{body} forms with an exception handler that
binds the raised object to @qvar{variable} and within the scope of that binding evaluates the
clauses as if they were the clauses of a @syntax{cond} expression.  That implicit @syntax{cond}
expression is evaluated with the continuation and dynamic environment of the @syntax{guard} form.
If every @qvar{cond-clause}'s @qvar{test} evaluates to @false{} and there is no @code{else} clause,
then @func{raise-continuable} is invoked on the raised object within the dynamic environment of the
original call to @func{raise} or @func{raise-continuable} except that the current exception handler
is that of the @syntax{guard} expression.
@end deffn


@anchor{raise}
@defun raise @var{obj}
Raise a @emph{non--continuable exception} by invoking the current exception handler on @var{obj}.

The handler is called with a continuation whose dynamic environment is that of the call to
@func{raise}, except that the current exception handler is the one that was in place when the
handler being called was installed.  So if the handler itself raises an exception: that exception
will be handled by the upper level handler; no infinite loop will happen by invoking the same
handler again and again.

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (A)
            (escape (cons 'A A)))
        (lambda ()
          (with-exception-handler
              (lambda (B)
                (raise (cons 'B B)))
            (lambda ()
              (with-exception-handler
                  (lambda (C)
                    (raise (cons 'C C)))
                (lambda ()
                  (raise 123)))))))))
@result{} (A B C . 123)
@end lisp

If the handler returns: a non--continuable exception with condition type @condition{non-continuable}
is raised in the same dynamic environment as the handler.

@lisp
(define C
  (call-with-current-continuation
      (lambda (escape)
        (with-exception-handler
            escape
          (lambda ()
            (with-exception-handler
                ;;This handler returns!
                (lambda (obj) obj)
              (lambda ()
                (raise 123))))))))

(condition? C)                  @result{} #t
(serious-condition? C)          @result{} #t
(violation? C)                  @result{} #t
(non-continuable-violation? C)  @result{} #t
(condition-irritants C)         @result{} (123)
@end lisp
@end defun


@anchor{raise-continuable}
@defun raise-continuable @var{obj}
Raise a @emph{continuable exception} by invoking the current exception handler on @var{obj}.  The
handler is called with a continuation that is equivalent to the continuation of the call to
@func{raise-continuable}, with these two exceptions:

@enumerate
@item
The current exception handler is the one that was in place when the handler being called was
installed.  So if the handler itself raises an exception: that exception will be handled by the
upper level handler; no infinite loop will happen by invoking the same handler again and again.

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (A)
            (escape (cons 'A A)))
        (lambda ()
          (with-exception-handler
              (lambda (B)
                (raise (cons 'B B)))
            (lambda ()
              (with-exception-handler
                  (lambda (C)
                    (raise (cons 'C C)))
                (lambda ()
                  (raise 123)))))))))
@result{} (A B C . 123)
@end lisp

@item
If the handler being called returns, then it will again become the current exception handler and the
values it returns become the values returned by the call to @func{raise-continuable}.

@lisp
(with-exception-handler
    ;;This handler returns 2 values!
    (lambda (obj)
      (values 'obj obj))
  (lambda ()
    (raise-continuable 123)))
@result{} obj 123
@end lisp
@end enumerate
@end defun

@c page
@node exceptions errors
@section Raising errors


@defun error @var{who} @var{message} @vari{irritant} @dots{}
@defunx assertion-violation @var{who} @var{message} @vari{irritant} @dots{}
@var{who} must be a string or a symbol or @false{}.  @var{message} must be a string.  The
@var{irritant}s are arbitrary objects.

These procedures raise a non--continuable exception.  The @func{error} procedure should be called
when an error has occurred, typically caused by something that has gone wrong in the interaction of
the program with the external world or the user.  The @func{assertion-violation} procedure should be
called when an invalid call to a procedure was made, either passing an invalid number of arguments,
or passing an argument that it is not specified to handle.

The @var{who} argument should describe the procedure or operation that detected the exception.  The
@var{message} argument should describe the exceptional situation.  The @var{irritant}s should be the
arguments to the operation that detected the violation.

The condition object provided with the exception has the following condition types:

@itemize
@item
If @var{who} is not @false{}, the condition has condition type @condition{who}, with @var{who} as
the value of its field.  In that case, @var{who} should be the name of the procedure or entity that
detected the exception.  If it is @false{}, the condition does not have condition type
@condition{who}.

@item
The condition has condition type @condition{message}, with @var{message} as
the value of its field.

@item
The condition has condition type @condition{irritants}, and its field has as
its value a list of the @var{irritant}s.
@end itemize

Moreover, the condition created by @func{error} has condition type
@condition{error}, and the condition created by @func{assertion-violation}
has condition type @condition{assertion}.

@example
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5)         @result{} 120
(fac 4.5)       @error{} exception &assertion
(fac -3)        @error{} exception &assertion
@end example
@end defun


@deffn Syntax assert @meta{expression}
An @func{assert} form is evaluated by evaluating @meta{expression}.  If @meta{expression} returns a
true value, that value is returned from the @func{assert} expression.  If @meta{expression} returns
@false{}, an exception with condition types @condition{assertion} and @condition{message} is raised.
The message provided in the condition object is implementation--dependent.
@end deffn

@c page
@node exceptions interop
@section Interoperability with @chicken{}


There is limited interoperability between the library @library{mmck exceptional-conditions} and the
module @library{chicken condition} bundled with @chicken{}.  We achieve it by setting @chicken{}'s
exception handler to @func{raise-continuable} at the top level:

@lisp
(module (demo)
    ()
  (import (scheme)
          (mmck exceptional-conditions)
          (prefix (chicken condition)
                  chicken::))

  (chicken::current-exception-handler raise-continuable)

  #| end of module |# )
@end lisp

@c ------------------------------------------------------------------------

With this setup we can catch exceptions raised with @func{signal} using @value{PACKAGE}'s
@func{with-exception-handler}:

@lisp
(define C
  (with-exception-handler
      ;;This handler returns.
      (lambda (E) E)
    (lambda ()
      (chicken::signal
       (chicken::make-property-condition 'demo
         'location  'me
         'message   "the message"
         'arguments '(1 2 3))))))

(chicken::get-condition-property C 'demo 'location)
@result{} me

(chicken::get-condition-property C 'demo 'message)
@result{} "the message"

(chicken::get-condition-property C 'demo 'arguments)
@result{} (1 2 3)
@end lisp

@noindent
and we can catch exceptions raised with @func{abort} using @value{PACKAGE}'s
@func{with-exception-handler}:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape
             (list
              (chicken::get-condition-property E 'demo 'location)
              (chicken::get-condition-property E 'demo 'message)
              (chicken::get-condition-property E 'demo 'arguments))))
        (lambda ()
          (chicken::abort
           (chicken::make-property-condition 'demo
             'location  'me
             'message   "the message"
             'arguments '(1 2 3)))))))
@result{} (me "the message" (1 2 3))
@end lisp

@noindent
notice that, due to how @func{abort} is defined, if the handler returns we enter an infinite loop,
exactly like it happens with @chicken{}'s @func{with-exception-handler}.

It is @strong{not possible} to handle exceptions raised with @func{raise} and
@func{raise-continuable} using @chicken{}'s @func{with-exception-handler}; however, we can catch
them and convert them:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (chicken::with-exception-handler
          (lambda (E)
            (escape (error? E)))
        (lambda ()
          (with-exception-handler
              chicken::signal
            (lambda ()
              (raise
               (condition
                 (make-error)
                 (make-who-condition 'me)
                 (make-message-condition "the message")
                 (make-irritants-condition '(1 2 3))))))))))
@result{} #t
@end lisp

@c page
@node syntaxes
@chapter Syntactic extensions


@menu
* syntaxes returnable::         Early return from code blocks.
* syntaxes unwind::             Unwind protection.
* syntaxes compensations::      Compensation stacks.
* syntaxes try::                The @syntax{try} syntax.
* syntaxes blocking::           Blocking exceptions.
@end menu

@c page
@node syntaxes returnable
@section Early return from code blocks


The standardised Scheme languages do not define the common @syntax{return} keyword present in many
languages, like C and Python.  Despite this, it is quite easy to obtain the ``early return''
functionality through the use of continuations:

@example
(call/cc
    (lambda (return)
      (display 'before)
      (return 1)
      (display 'never)))
@print{} before
@result{} 1
@end example

Many programmers are used to the @syntax{return} keyword, so @value{PACKAGE} includes some syntaxes
to support it.  The use of all these syntaxes involves the creation of a continuation, which is a
performance penalty.


@deffn Syntax return @qvar{expr} @dots{}
This syntax is meant to be used to return from some enclosing block, returning the given optional
arguments.  Being a fluid syntax: it is possible to rebind this keyword in custom syntaxes.
@end deffn


@anchor{returnable}
@deffn Syntax returnable @qvaro{body} @qvar{body} @dots{}
Like @func{begin}, but allow the use of the keyword @func{return} to return values to the enclosing
continuation.
@end deffn


Usage examples:

@lisp
(returnable
  (display 'before)
  (return)
  (display 'never))
@print{} before

(returnable
  (display 'before)
  (return 1)
  (display 'never))
@print{} before
@result{} 1

(returnable
  (display 'before)
  (return 1 2)
  (display 'never))
@print{} before
@result{} 1 2
@end lisp

@c page
@node syntaxes unwind
@section Unwind protection


Unwind--protection allows operations to be performed synchronously with respect to the dynamic
extent of a call to thunk; the mechanism is sophisticated because there are multiple, sophisticated
ways to exit the dynamic extent of a function call.  The typical application is to release
asynchronous resources, like input/output ports and database connections.

To understand the unwind--protection mechanism we must understand the concepts ``dynamic extent of a
function call'' and ``dynamic environment'' as defined by the Scheme standard.

The unwind--protection mechanism described here is used by @value{PACKAGE} in: the implementation of
compensations (@pxref{syntaxes compensations}); the implementation of the syntax @syntax{try}
(@pxref{syntaxes try}).

@quotation
@strong{NOTE} The unwind protection mechanism may misbehave in some cases, so do not trust it
blindly (@pxref{syntaxes unwind problems}).
@end quotation

@menu
* syntaxes unwind intro::       Introduction to the unwind protection
                                mechanism.
* syntaxes unwind syntaxes::    Unwind-protection syntaxes.
* syntaxes unwind dynamic::     On the meaning of dynamic extent termination.
* syntaxes unwind except 1::    Raising non-continuable exceptions from
                                the thunk.
* syntaxes unwind except 2::    Raising continuable exceptions from the
                                thunk.
* syntaxes unwind except 3::    Raising exceptions from the unwind handler.
* syntaxes unwind returnable::  Use with returnable bodies.
@c * syntaxes unwind coroutines::  Use with coroutines.
* syntaxes unwind reenter::     Handling reentering continuations.
* syntaxes unwind dyn-env::     Clean-up thunks and the dynamic environment.
* syntaxes unwind problems::    Known problems.
* syntaxes unwind call/cc::     Unwinding @func{call/cc}.
@end menu

@c page
@node syntaxes unwind intro
@subsection Introduction to the unwind--protection mechanism


The syntax @syntax{with-unwind-handler} implements the core mechanism.  @syntax{unwind-protect}
offers a syntax similar to the one of the Common Lisp macro with the same name.  The former is meant
to be used as follows:

@lisp
(let ((port (open-output-file "file.ext")))
  (with-unwind-handler
      (lambda (why)
        (close-output-port port))
    (lambda ()
      (put-bytevector port '#ve(ascii "ciao")))))
@end lisp

@noindent
and the latter as follows:

@lisp
(let ((port (open-output-file "file.ext")))
  (unwind-protect
      (put-bytevector port '#ve(ascii "ciao"))
    (close-output-port port)))
@end lisp

@noindent
first we allocate a resource (in this case the @var{port}); then we use it in the body forms;
finally we release it in the clean--up forms.

When using the mechanism:

@itemize
@item
We have to decide if we trust our code not to raise exceptions while evaluating the in--guard and
out--guard thunks of @func{dynamic-wind} calls.  These would be nasty errors, because the dynamic
environment would get corrupted and recovering correctly might be impossible; so we must
@strong{really} write and debug such in--guard and out--guard thunks with care.

@item
We have to decide if we trust our code not to raise a second exception while serving a first
exception in an error handler.  Raising a continuable exception is fine only if we actually
continue.  Exceptions while handling exceptions are a hard problem to solve in every language; the
rough solution is to block exceptions raised by exception handlers:

@lisp
(with-exception-handler
    (lambda (E)
      (with-blocked-exceptions
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp

@noindent
but it is not very satisfying.  Another possibility is:

@lisp
(define-condition-type &originally-raised
    &condition
  make-originally-raised-condition
  originally-raised-condition?
  (object originally-raised-object))

(with-exception-handler
    (lambda (E)
      (with-exception-handler
          (lambda (X)
            (raise-continuable
              (condition X
                (make-originally-raised-condition E))))
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp
@end itemize

If the bodacious answer to both the decisions is ``We trust'': we can nest at will uses of
@syntax{with-unwind-handler}:

@lisp
(define (outer)
  (with-unwind-handler
      (lambda (why)
        (outer-unwind-handler))
    (lambda ()
      (do-something-useful)
      (inner))))

(define (inner)
  (with-unwind-handler
      (lambda (why)
        (inner-unwind-handler))
    (lambda ()
      (do-some-other-useful-thing))))

(outer)
@end lisp

@noindent
@strong{beware}: unwind handlers are evaluated in the dynamic environment of the use of
@syntax{with-unwind-handler}.

Otherwise, we must avoid error handlers to cause the execution flow to cross an unwind protection
boundary; we can do it by using compensations and the standard @syntax{guard} syntax:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (guard (E ((type-one-error? E)
                 (handle E))
                (else
                 (do-something-dammit!!!)))
        (outer)))))
@end lisp

@noindent
or by using the compensations and the @syntax{try} syntax defined by @value{PACKAGE}:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (try
          (outer)
        (catch E
          ((&type-one)
           (handle E))
          (else
           (do-something-dammit!!!)))))))
@end lisp

@noindent
@strong{beware}: compensation handlers are evaluated in the dynamic environment of the use of
@syntax{with-compensations}.

@c page
@node syntaxes unwind syntaxes
@subsection Unwind--protection syntaxes


@deffn Syntax with-unwind-handler @qvar{unwind-handler} @qvar{thunk}
Call @qvar{thunk} and then, when the dynamic extent of the call @strong{terminates}, call the
procedure @qvar{unwind-handler}.  When @qvar{thunk} performs a normal return: the return values of
@qvar{thunk} become the return values of @func{with-unwind-handler}.

When called: @qvar{unwind-handler} is applied to a Scheme symbol representing the cause of the call:
@samp{return}, @samp{escape}, @samp{exception}.  The argument @qvar{unwind-handler} comes before the
argument @qvar{thunk} for uniformity with @func{with-exception-handler};
@ref{with-exception-handler} for details.

Notice that a function tail--call in @qvar{thunk} is @strong{not} a tail--call for
@syntax{with-unwind-handler}.
@end deffn


@deffn Syntax unwind-protect @qvar{body} @qvaro{cleanup} @qvar{cleanup} ...
Simple wrapper for @syntax{with-unwind-handler} that provides a syntax similar to that of Common
Lisp's macro.  It is expanded to:

@example
(with-unwind-handler
    (lambda (dummy) @qvaro{cleanup} @qvar{cleanup} ...)
  (lambda () @qvar{body}))
@end example
@end deffn

@c page
@node syntaxes unwind dynamic
@subsection On the meaning of dynamic extent termination


The concept of dynamic extent @dfn{termination} is defined by @value{PACKAGE}'s unwind--protection
mechanism and it is not a standard Scheme concept.  In this discussion, we consider the syntax use:

@example
(with-unwind-handler @qvar{unwind-handler} @qvar{thunk})
@end example

@noindent
the procedure @qvar{unwind-handler} is called when the dynamic extent of the invocation of
@qvar{thunk} terminates; dynamic extent @strong{termination} is different from dynamic extent
@strong{exiting} as determined by @func{dynamic-wind}.  When the execution flow exits the dynamic
extent of a function call: such extent might also terminate, but not all the exits are also
terminations.

The dynamic extent of a call to @qvar{thunk} @strong{is} terminated, and so @qvar{unwind-handler}
@strong{is} invoked, when:

@itemize
@item
@qvar{thunk} performs a normal return.  @qvar{unwind-handler} is applied to the symbol
@samp{return}.

@item
@qvar{thunk} raises a continuable or non--continuable exception that is intercepted by a use of
@syntax{guard}, but only when a clause of @syntax{guard} has a test expression returning non--false.

@lisp
(guard (E (@qvar{test} @qvar{expr}))
  (with-unwind-handler @qvar{unwind-handler} @qvar{thunk}))
@end lisp

This is what happens:

@enumerate
@item
The clause's @qvar{test} expression is evaluated in the dynamic environment of the use of
@syntax{guard} and it returns non--false.

@item
@qvar{unwind-handler} is applied to the symbol @samp{exception}, in the dynamic environment of the
use of @syntax{with-unwind-handler}, and its return values discarded.

@item
The clause's @qvar{expr} is evaluated in the dynamic environment of the use of @syntax{guard} and
its return values are returned to the continuation of @syntax{guard}.
@end enumerate

@item
@qvar{thunk} executes a use of the syntax @syntax{return}, as defined by the library @library{mmck
exceptional-condition}, to escape from a form that encloses an unwind--protection syntax.
@qvar{unwind-handler} is applied to the symbol @samp{escape}.

As bound by the @syntax{returnable}: the syntax @syntax{return} reinstates a continuation at the
beginning or outside of @syntax{returnable} and performs special operations to terminate the dynamic
extent of the call to @qvar{thunk} in an unwind--protection form.
@end itemize

@c ------------------------------------------------------------------------

The dynamic extent of a call to @qvar{thunk} is @strong{not} terminated, and so
@qvar{unwind-handler} is @strong{not} invoked, when:

@itemize
@item
@qvar{thunk} raises a continuable exception by calling @func{raise-continuable}, and such call
performs a normal return to @qvar{thunk}.

@item
@qvar{thunk} raises a continuable or non--continuable exception and an exception handler terminates
the process (for example by calling @func{exit}).

@c @item
@c The unwind--protection syntax is used by a coroutine and @func{yield} is called from within
@c @qvar{thunk} to hand control to another coroutine.

@item
An escape procedure is called from within @qvar{thunk} to reinstate a continuation outside
@qvar{thunk}, and the call to the escape procedure is @strong{not} interfaced with the
unwind--protection mechanism to terminate the dynamic extent of the call to @qvar{thunk}.
@end itemize

@c ------------------------------------------------------------------------

About the termination of the dynamic extent of @qvar{thunk}, we must acknowledge that:

@itemize
@item
There is @strong{no} guarantee that: after exiting (without terminating) the dynamic extent of
@qvar{thunk} by reinstating a continuation, such extent will be reentered later and continue to
termination.

@item
If the dynamic extent of @qvar{thunk} is terminated and an attempt to reenter @qvar{thunk} is
performed: an exception is raised with compound condition object containing a
@condition{non-reinstatable} component (@pxref{&non-reinstatable}).

@item
Obviously, if a call to @qvar{unwind-handler} raises an exception: the clean--up operations
performed by @qvar{unwind-handler} may fail, in whole or in part, possibly leaving behind unreleased
resources.

@item
If the call to @qvar{thunk} raises an exception and a use of @syntax{guard} intercepts it: if a test
expression in a clause of @syntax{guard} raises an exception, the @qvar{unwind-handler} may not be
called.

While it is possible to @func{raise} any object: it is better to always raise a condition object
(possibly compound), so that the test expressions in @syntax{guard} uses can just be condition
object type predicates; such predicates never raise exceptions.
@end itemize

@c ------------------------------------------------------------------------

If @qvar{unwind-handler} raises an exception: such exception is blocked and discarded.

@c page
@node syntaxes unwind except 1
@subsection Raising non--continuable exceptions from the thunk


A non--continuable exception is raised with @func{raise}, which can be applied to any object; the
argument to @func{raise} becomes the ``raised object''.  The purpose of raising a non--continuable
exception is to cause the application of a function, the current exception handler, to the raised
object; the exception handler is called in the dynamic environment of the call to @func{raise}, with
the exception that the ``current exception handler'' is the one that was previously installed
(@pxref{raise} for a precise description of the operation).

The execution flow is @strong{not} meant return to the caller of @func{raise}, so the exception
handler has only two options:

@enumerate
@item
Reinstate a previously saved continuation to jump out of the dynamic environment in which the
exception was raised.  The following example shows the basic mechanism:

@lisp
(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (raise 1)))))
@result{} 1
@end lisp

@noindent
Reinstating a continuation to jump out of the exception handler is what the standard @syntax{guard}
syntax does when it handles an exception; @syntax{guard} does more than this.

@item
Raise the exception again, causing the invocation of the upper level exception handler.  The
following example shows the basic mechanism:

@lisp
(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise E))
            (lambda ()
              (raise 1)))))))
@result{} 1
@end lisp
@end enumerate

@c ------------------------------------------------------------------------

@subsubheading Handling exceptions by escaping

This is @strong{not} the correct way of interfacing with the unwind--protection mechanism.  In the
following example we see that escaping from the exception handler skips the call to the
@qvar{unwind-handler}.

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape E))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (add-result 'thunk-in)
                (raise 123)
                (add-result 'thunk-out))))))))
@result{} (123 (thunk-in exception-handler))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Handling exceptions with @syntax{guard}

This is the correct way of interfacing with the unwind--protection mechanism.

In the following example: the @qvar{thunk} raises a non--continuable exception, which is caught by
the @syntax{else} clause of a @syntax{guard} use; this is equivalent to escaping from an exception
handler, but it does evaluate the @qvar{unwind-handler}.  We can see the forms evaluation order.

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-handler
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in cleanup guard-else))
@end lisp

In the following example: the @qvar{thunk} raises a non--continuable exception, which is caught by
the clause of a @syntax{guard} use; the clause has test and expression.  We can see the forms
evaluation order.

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (guard (E ((begin
               (add-result 'guard-test)
               #t)
             (add-result 'guard-expr)
             E))
    (with-unwind-handler
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in guard-test cleanup guard-expr))
@end lisp

The following example with two nested @syntax{guard} uses and two nested @func{dynamic-wind} calls,
makes it even more clear the sequence of forms evaluation.  The clause of the inner @syntax{guard}
has test expression returning @false{}, so the exception is re--raised with
@func{raise-continuable}.

@lisp
(import (only (mmck checks)
        with-result
        add-result))

(with-result
  (guard (E ((begin
               (add-result 'outer-guard-test)
               #t)
             (add-result 'outer-guard-expr)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 #f)
               (add-result 'inner-guard-expr)
               E))
      (dynamic-wind
          (lambda ()
            (add-result 'outer-before))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (dynamic-wind
                    (lambda ()
                      (add-result 'inner-before))
                    (lambda ()
                      (add-result 'thunk-in)
                      (raise 2)
                      (add-result 'thunk-out)
                      1)
                    (lambda ()
                      (add-result 'inner-after))))))
          (lambda ()
            (add-result 'outer-after))))))
@result{} (2 (outer-before inner-before thunk-in inner-after outer-after
       inner-guard-test
       outer-before inner-before inner-after outer-after
       outer-guard-test
       outer-before inner-before inner-after cleanup outer-after
       outer-guard-expr))
@end lisp

Let's describe the sequence of operations:

@table @code
@item outer-before inner-before thunk-in
Everything goes fine until the @qvar{thunk} reaches @code{thunk-in}.

@item *
The @qvar{thunk} raises an exception.  The exception handler of the inner @syntax{guard} is applied
to the raised object.

@item inner-after outer-after
The continuation of the inner @syntax{guard} use is reinstated, the dynamic extent of the call to
@qvar{thunk} is exited: the dynamic environment unwinds.

@item inner-guard-test
The clause test expression of the inner @syntax{guard} is evaluated in the dynamic environment of
the @syntax{guard} use: it returns @false{}.

@item outer-before inner-before
The continuation of the inner @syntax{guard} exception handler is reinstated, the dynamic extent of
the call to @qvar{thunk} is reentered: the dynamic environment is restored.

@item *
The exception is raised again by applying @func{raise-continuable} to the same raised object.  The
exception handler of the outer @syntax{guard} is applied to the raised object.

@item inner-after outer-after
The continuation of the outer @syntax{guard} use is reinstated, the dynamic extent of the call to
@qvar{thunk} is exited: the dynamic environment unwinds.

@item outer-guard-test
The clause test expression of the outer @syntax{guard} is evaluated in the dynamic environment of
the outer @syntax{guard}: it returns @true{}.

@item outer-before inner-before
The continuation of the of the outer @syntax{guard} exception handler is reinstated, the dynamic
extent of the call to @qvar{thunk} is entered: the dynamic environment is restored.

@item inner-after cleanup outer-after
The continuation of the outer @syntax{guard} clause is reinstated, the the dynamic extent of the
call to @qvar{thunk} is exited: the dynamic environment unwinds.  While unwinding: the @qvar{thunk}
is found terminated and the @qvar{unwind-handler} is called in the dynamic environment of the
@syntax{with-unwind-handler} use.

@item outer-guard-expr
The clause expression of the outer @syntax{guard} is evaluated in the dynamic environment of the
outer @syntax{guard}.
@end table

That's Scheme!

@c page
@node syntaxes unwind except 2
@subsection Raising continuable exceptions from the thunk


A continuable exception is raised with @func{raise-continuable} and it is a way to resume the
execution of a chunk of code after raising an exception.  This example shows the basic mechanism:

@lisp
(with-exception-handler
    (lambda (E)
      (+ E 2))
  (lambda ()
    (raise-continuable 1)))
@result{} 3
@end lisp

The handling of a continuable exception can be the same of the handling of a non--continuable
exception; in addition the exception handler is allowed to return.  In the latter case the dynamic
extent of the call to @qvar{thunk} is @strong{not} exited, so @qvar{unwind-handler} is not called.

The following example shows what happens when @qvar{thunk} raises a continuable exception:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (with-exception-handler
      (lambda (E)
        (add-result 'exception-handler)
        (+ E 2))
    (lambda ()
      (with-unwind-handler
          (lambda (why)
            (add-result 'cleanup))
        (lambda ()
          (add-result 'thunk-in)
          (begin0
              (raise-continuable 1)
            (add-result 'thunk-out)))))))
@result{} (3 (thunk-in exception-handler thunk-out cleanup))
@end lisp

@c page
@node syntaxes unwind except 3
@subsection Raising exceptions from the unwind handler


When a thunk raises an exception and the current exception handler raises another exception: the
original exception is dropped if no specific action is taken.  This is a common problem.  The
following example shows the mechanism.

@lisp
(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise 2))
            (lambda ()
              (raise 1)))))))
@result{} 2
;;The originally raised value 1 is lost!
@end lisp

What happens if @qvar{unwind-handler} raises an exception?  It was decided that such exceptions are
to be blocked and discarded; @qvar{unwind-handler} procedures have to take care of themselves,
handling their own errors.  The following example shows the mechanism.

@lisp
(import (only (mmck checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-handler
        (lambda (why)
          (add-result 'cleanup-in)
          (raise 2)
          (add-result 'cleanup-out))
      (lambda ()
        (add-result 'thunk-in)
        (raise 1)
        (add-result 'thunk-out)))))
@result{} (1 (thunk-in cleanup-in guard-else))
@end lisp

@c page
@node syntaxes unwind returnable
@subsection Use with returnable bodies


The unwind--protection mechanism has special integration with the @syntax{returnable} syntax
(@pxref{returnable}); if an unwind--protection syntax is used in the body of @syntax{returnable} and
@syntax{return} is used in the body forms: the unwind handler is evaluated correctly.  We have to
remember that @syntax{return} is implemented by an escaping continuation.

@lisp
(define y #f)

(returnable
  (with-unwind-handler
      (lambda (why)
        (set! y #t))
    (lambda ()
      (return 1))))
@result{} 1
y @result{} #t
@end lisp

@c page
@c @node syntaxes unwind coroutines
@c @subsection Use with coroutines


@c Using the unwind--protection mechanism with coroutines is fine; coroutines use @func{yield} to save
@c the current continuation, give control to the next coroutine and come back later; this mechanism
@c does not cause the @qvar{unwind-handler} evaluation.

@c The following sample code finishes with the given return values and
@c lines printed:

@c @lisp
@c (import (vicare))

@c (define (print template . args)
@c   (apply fprintf (current-error-port) template args)
@c   (yield))

@c (define a #f)
@c (define b #f)
@c (define c #f)

@c (concurrently
@c   (lambda ()
@c     (unwind-protect
@c         (begin
@c           (set! a 1.1)
@c           (print "unwind-protect sub 1.1: ~a\n" a)
@c           (set! a 1.2)
@c           (print "unwind-protect sub 1.2: ~a\n" a)
@c           (set! a 1.3)
@c           (print "unwind-protect sub 1.3: ~a\n" a))
@c       (set! a 1.4)))
@c   (lambda ()
@c     (unwind-protect
@c         (begin
@c           (set! b 2.1)
@c           (print "unwind-protect sub 2.1: ~a\n" b)
@c           (set! b 2.2)
@c           (print "unwind-protect sub 2.2: ~a\n" b)
@c           (set! b 2.3)
@c           (print "unwind-protect sub 2.3: ~a\n" b))
@c       (set! b 2.4)))
@c   (lambda ()
@c     (unwind-protect
@c         (begin
@c           (set! c 3.1)
@c           (print "unwind-protect sub 3.1: ~a\n" c)
@c           (set! c 3.2)
@c           (print "unwind-protect sub 3.2: ~a\n" c)
@c           (set! c 3.3)
@c           (print "unwind-protect sub 3.3: ~a\n" c))
@c       (set! c 3.4))))

@c (values a b c)
@c @result{} 1.4 2.4 3.4
@c @print{} unwind-protect sub 1.1: 1.1
@c @print{} unwind-protect sub 2.1: 2.1
@c @print{} unwind-protect sub 1.2: 1.2
@c @print{} unwind-protect sub 3.1: 3.1
@c @print{} unwind-protect sub 2.2: 2.2
@c @print{} unwind-protect sub 1.3: 1.3
@c @print{} unwind-protect sub 3.2: 3.2
@c @print{} unwind-protect sub 2.3: 2.3
@c @print{} unwind-protect sub 3.3: 3.3
@c @end lisp

@c page
@node syntaxes unwind reenter
@subsection Handling reentering continuations


After the @qvar{unwind-handler} is called: we do @strong{not} want the execution flow to reenter the
@qvar{thunk} in the same dynamic extent.  After the dynamic extent of a call to @qvar{thunk}
terminates, and the @qvar{unwind-handler} is called: we are forbidden to reenter the @qvar{thunk};
if we try to reenter: an exception of type @condition{non-reinstatable} is raised.

The first problem with reentering is that the code in the @qvar{thunk} expects invariants in the
state of the process that are no longer true; for example: if @qvar{unwind-handler} closes an
input/output port, the @qvar{thunk} still expects it to be open.

Reentering might happen, for example, when using McCarthy's @syntax{amb} operator in the
@qvar{thunk}.  This means we must be careful to use @syntax{amb} in a @qvar{thunk} only when the
whole search never crosses the unwind protection contour.

The following example shows how calling an escape procedure created in the @qvar{thunk} of a
@syntax{with-unwind-handler} causes the exception to be raised:

@lisp
(import (only (mmck checks)
        with-result
        add-result))

(with-result
  (guard (E ((non-reinstatable-violation? E)
             (add-result 'violation)
             #t)
            (else E))
    (let ((rv (with-unwind-handler
                  (lambda (why)
                    (add-result 'cleanup))
                (lambda ()
                  (add-result 'body-in)
                  (begin0
                      (call/cc values)
                    (add-result 'body-out))))))
      (cond ((procedure? rv)
             (add-result 'reinstating)
             (rv 123))
            (else
             (add-result 'returning)
             rv)))))
@result{} (#t (body-in body-out cleanup reinstating violation))
@end lisp

@c page
@node syntaxes unwind dyn-env
@subsection Clean--up thunks and the dynamic environment


As @rnrs{6} states:

@quotation
Some operations described in the report acquire information in addition to their explicit arguments
from the @emph{dynamic environment}.  For example, @func{call/cc} accesses an implicit context
established by @func{dynamic-wind}, and the @func{raise} procedure accesses the current exception
handler.
@end quotation

@noindent
the typical example of values from the dynamic environment is parameters, which indeed are
implemented on top of @func{dynamic-wind}.  When using the unwind--protection mechanism:

@lisp
(with-unwind-handler @qvar{unwind-handler} @qvar{thunk})
@end lisp

@noindent
the procedure @qvar{unwind-handler} is called in the dynamic environment of the use of
@syntax{with-unwind-handler}.

For example, when escaping from @qvar{thunk} with @syntax{return}:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(define parm
  (make-parameter #f))

(with-result
  (parameterize ((parm 'outer-parm))
    (returnable
      (parameterize ((parm 'inner-parm))
        (with-unwind-handler
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in inner-parm cleanup-out))
@end lisp

@noindent
we see that, even though @syntax{return} reinstates the continuation of @syntax{returnable}:
@qvar{unwind-handler} gathers the parameter value from inside the use of @syntax{returnable}.

Even more descriptive is the case of raising an exception from @qvar{thunk} and catching it with
@syntax{guard}:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(define parm
  (make-parameter #f))

(with-result
  (parameterize ((parm 'outer-parm))
    (guard (E ((begin
                 (add-result 'guard-test-in)
                 (add-result (parm))
                 (add-result 'guard-test-out)
                 #t)
               (add-result 'guard-expr-in)
               (add-result (parm))
               (add-result 'guard-expr-out)
               E))
      (parameterize ((parm 'inner-parm))
        (with-unwind-handler
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (raise 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       guard-test-in outer-parm guard-test-out
       cleanup-in inner-parm cleanup-out
       guard-expr-in outer-parm guard-expr-out))
@end lisp

@noindent
both @qvar{thunk} and @qvar{unwind-handler} gather the inner value, while the test and expression of
the @syntax{guard} clause gather the outer value, even though the execution order is intermixed.

Changing the environment inside @qvar{thunk} does not affect @qvar{unwind-handler}:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(define parm
  (make-parameter #f))

(with-result
  (parameterize ((parm 'outer-parm))
    (with-unwind-handler
        (lambda (why)
          (add-result 'cleanup-in)
          (add-result (parm))
          (add-result 'cleanup-out))
      (lambda ()
        (parameterize ((parm 'inner-parm))
          (add-result 'thunk-in)
          (add-result (parm))
          (add-result 'thunk-out)
          1)))))
@result{} (1 (thunk-in inner-parm thunk-out
       cleanup-in outer-parm cleanup-out))

(with-result
  (returnable
    (parameterize ((parm 'outer-parm))
      (with-unwind-handler
          (lambda (why)
            (add-result 'cleanup-in)
            (add-result (parm))
            (add-result 'cleanup-out))
        (lambda ()
          (parameterize ((parm 'inner-parm))
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in outer-parm cleanup-out))
@end lisp

@c page
@node syntaxes unwind problems
@subsection Known problems


The unwind protection mechanism may misbehave in some cases.  Specifically the unwind handler may
not be called in the following cases:

@itemize
@item
An exception is raised by a thunk and, while handling it, a second exception is raised.

@item
An exception is raised by the in--guard or out--guard thunks of a call to @func{dynamic-wind}.
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from an exception handler

In the following example an exception is raised by an exception handler: the unwind handler is
called, but the original exception is lost.

@example
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-exception-handler
        (lambda (E)
          (add-result 'exception-handler)
          (raise 2))
      (lambda ()
        (with-unwind-handler
            (lambda (why)
              (add-result 'unwind-handler))
          (lambda ()
            (dynamic-wind
                (lambda ()
                  (add-result 'in-guard))
                (lambda ()
                  (add-result 'thunk-in)
                  (raise 1)
                  (add-result 'thunk-out))
                (lambda ()
                  (add-result 'out-guard)))))))))
@result{} (2 (in-guard
       thunk-in
       exception-handler
       out-guard
       in-guard out-guard unwind-handler
       guard-else))
@end example

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from a @syntax{guard}'s test

In the following example an exception is raised from a @syntax{guard}'s test expression: the unwind
handler is @strong{not} called and the original exception is lost.

@example
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (guard (E (else
             (add-result 'outer-guard-else)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 (raise 2))
               E))
      (with-unwind-handler
          (lambda (why)
            (add-result 'unwind-handler))
        (lambda ()
          (dynamic-wind
              (lambda ()
                (add-result 'in-guard))
              (lambda ()
                (add-result 'thunk-in)
                (raise 1)
                (add-result 'thunk-out))
              (lambda ()
                (add-result 'out-guard))))))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       inner-guard-test
       outer-guard-else))
@end example

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from @func{dynamic-wind} guards

In the following example an exception is raised from a @func{dynamic-wind}'s in--guard thunk: the
unwind handler is @strong{not} called and the original exception is lost.

@example
(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (dynamic-wind
        (let ((flag #f))
          (lambda ()
            (cond (flag
                   (add-result 'in-guard/raise)
                   (raise 2))
                  (else
                   (set! flag #t)
                   (add-result 'in-guard)))))
        (lambda ()
          (with-unwind-handler
              (lambda (E)
                (add-result 'unwind-handler))
            (lambda ()
              (add-result 'thunk-in)
              (raise 1))))
        (lambda ()
          (add-result 'out-guard)))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       in-guard/raise
       guard-else))
@end example

@c page
@node syntaxes unwind call/cc
@subsection Unwinding @func{call/cc}


We have seen that performing a raw escape from an exception handler skips calling the unwind
handlers installed in the body:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape 2))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'unwind-handler))
              (lambda ()
                (add-result 'body-in)
                (raise 1))))))))
@result{} (2 (body-in exception-handler))
@end lisp

@noindent
this problem can be solved by using @func{unwinding-call/cc} rather than the standard
@func{call/cc}.


@defun unwinding-call/cc @var{receiver}
Similar to @func{call/cc}, but calling the escape procedure causes the invocation of the unwind
handlers installed in the dynamic environment up until the saved continuation is restored.

There are limitations:

@itemize
@item
The escape procedure produced by this primitive @strong{must} be called only from the dynamic extent
of the call to @var{receiver}.  For example: generating an unwinding escape procedure in a coroutine
and calling it from another coroutine leads to raising an exception of type
@condition{non-reinstatable}.

@item
The escape procedure produced by this primitive @strong{must} be called only once; an attempt to
call it a second time leads to raising an exception of type @condition{non-reinstatable}.
@end itemize

@quotation
@strong{NOTE} After some development iterations, the implementation of this primitive has taken a
shape quite similar to the function @func{call/cc-escaping} proposed by Will Clinger in
@url{http:/@//@/www.ccs.neu.edu/@/home/@/will/@/UWESC/@/uwesc.sch}.
@end quotation
@end defun


Usage examples:

@lisp
(import (only (mmck checks)
              with-result
              add-result))

(with-result
  (unwinding-call/cc
      (lambda (escape)
        (with-unwind-handler
            (lambda (why)
              (add-result 'unwind-handler))
          (lambda ()
            (add-result 'body-in)
            (escape 1))))))
@result{} (1 (body-in unwind-handler))

(with-result
  (unwinding-call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape 2))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'unwind-handler))
              (lambda ()
                (add-result 'body-in)
                (raise 1))))))))
@result{} (2 (body-in exception-handler unwind-handler))

;;Calling unwinding escape procedure from outside the
;;dynamic extent of the call to the receiver.
;;
(let ((escape-proc #f))
  (unwinding-call/cc
      (lambda (escape)
        (set! escape-proc escape)))
  (escape-proc))
@error{} &non-reinstatable

;;Calling unwinding escape procedure twice.
;;
(let ((again-proc #f))
  (unwinding-call/cc
      (lambda (escape)
        (call/cc
            (lambda (again)
              (set! again-proc again)))
        (escape)))
  (again-proc))
@error{} &non-reinstatable
@end lisp

@c page
@node syntaxes compensations
@section Compensation stacks

@c page
@node syntaxes try
@section The @syntax{try} syntax


@c page
@node syntaxes blocking
@section Blocking exceptions


@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

The original version of the @rnrs{6} document, and its errata, are available at:

@center @url{http://www.r6rs.org/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
