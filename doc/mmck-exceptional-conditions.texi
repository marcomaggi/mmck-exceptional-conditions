\input texinfo.tex
@c %**start of header
@setfilename mmck-exceptional-conditions.info
@settitle @sc{mmck} Exceptional Conditions
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Exceptional Conditions for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Exceptional Conditions

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-exceptional-conditions

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                exceptional-conditions

@set PackageAutoconfPrefix      MMCK_EXCEPTIONAL_CONDITIONS
@set PackagePkgconfigModule     mmck-exceptional-conditions

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional--conditions.  @chicken{} is a Scheme--to--C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-exceptional-conditions: (mmck-exceptional-conditions).
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* conditions::                  Exceptional-condition objects.
* exceptions::                  Handling exceptional-conditions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck exceptional-conditions}, library
@cindex Library @library{mmck exceptional-conditions}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language library
implementing facilities to handle exceptional conditions.  @chicken{} is a Scheme-to-C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  This package depends upon the @chicken{} egg
@code{matchable}.  To run the tests distributed with the source code: this package depends upon the
package @mmck{} Checks.

@value{PACKAGE} defines an @api{} derived from the one specified in the ``Revised^6 Report on the
Algorithmic Language Scheme'' (@rnrs{6}); this document itself contains revised sections of the
original @rnrs{6} document.  While similar, the two @api{}s are not equal; however, this package
should make it easier to port @rnrs{6} code to @chicken.

The package installs the library @library{mmck exceptional-conditions} along with its import
library; this library has naming conflicts with the module @library{chicken condition} bundled with
@chicken{}.  To require the library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck exceptional-conditions))

(module (my-module)
    ()
  (import (scheme)
    (mmck exceptional-conditions))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node conditions
@chapter Exceptional--condition objects


@cindex Exceptional--condition objects
@cindex Exceptional--condition object--types
@cindex Condition object--types


This section describes an @api{} for creating and inspecting condition types and values.  A
condition value encapsulates information about an exceptional situation; the @api{} also defines a
number of basic condition types.  This @api{} and this documentation section are derived from the
ones defined by @rnrs{6}, but the underlying condition objects representation is the one built--in
into @chicken{} and defined by the module @library{chicken condition}.

Scheme conditions provide two mechanisms to enable communication about an exceptional situation:
subtyping among condition types allows handling code to determine the general nature of an exception
even though it does not anticipate its exact nature, and compound conditions allow an exceptional
situation to be described in multiple ways.

@menu
* conditions objects::          Condition objects.
* conditions types::            Predefined condition types.
@end menu

@c page
@node conditions objects
@section Condition objects


Conceptually, there are two different kinds of condition objects: @emph{simple conditions} and
@emph{compound conditions}.  An object that is either a simple condition or a compound condition is
simply a @emph{condition}.  Compound conditions form a type disjoint from the base types.  A simple
condition describes a single aspect of an exceptional situation.  A compound condition represents
multiple aspects of an exceptional situation as a list of simple conditions, its @emph{components}.
Most of the operations described in this section treat a simple condition identically to a compound
condition with itself as its own sole component.


@deftp {Condition Kind} {&condition}
Simple conditions are formal subtypes of the @condition{condition} kind.  The @condition{condition}
kind has no fields.
@end deftp


@defun condition @vari{condition} @dots{}
Return a condition object with the components of the @var{condition}s as its components, in the same
order, i.e., with the components of @vari{condition} appearing first in the same order as in
@vari{condition}, then with the components of @varii{condition}, and so on.  The returned condition
is compound if the total number of components is zero or greater than one.  Otherwise, it may be
compound or simple.
@end defun


@defun simple-conditions @var{condition}
The @func{simple-conditions} procedure returns a list of the components of @var{condition}, in the
same order as they appeared in the construction of @var{condition}.  The returned list is immutable.
If the returned list is modified, the effect on @var{condition} is unspecified.

@quotation
@strong{NOTE} Because @func{condition} decomposes its arguments into simple conditions,
@func{simple-conditions} always returns a ``flattened'' list of simple conditions.
@end quotation
@end defun


@defun {condition?} @var{obj}
Return @true{} if @var{obj} is a (simple or compound) condition, otherwise return @false{}.
@end defun


@defun condition-kinds @var{obj}
The argument @var{obj} must be a condition object, either simple or compound.  Return a list of
symbols representing the condition kinds in @var{obj}; the list may contain duplicates.

@lisp
(condition-kinds
  (condition (make-error)
             (make-who-condition 'me)
             (make-message-condition "the message")
             (make-irritants-condition '(1 2 3))))
@result{} (&error &serious &condition
    &who &condition
    &message &condition
    &irritants &condition)
@end lisp
@end defun


@deffn Syntax define-condition-type @qvar{condition-kind} @qvar{supertype} @qvar{constructor} @qvar{predicate} @qvari{field-spec} @dots{}
@qvar{condition-kind}, @qvar{supertype}, @qvar{constructor}, and @qvar{predicate} must all be
identifiers.  Each @qvar{field-spec} must be of the form

@example
(@qvar{field} @qvar{accessor})
@end example

@noindent
where both @qvar{field} and @qvar{accessor} must be identifiers.

The @func{define-condition-type} form expands into a group of definitions for the constructor,
predicate and field accessors for a new condition kind @qvar{condition-kind}.  The identifiers will
be bound as follows:

@itemize
@item
@qvar{constructor} is bound to a default constructor for the kind: it accepts one argument for each
of the record kind's complete set of fields (including parent kinds, with the fields of the parent
coming before those of the extension in the arguments) and returns a condition object initialised to
those arguments.  The returned object is a compound that contains the kind @qvar{condition-kind},
the kind @qvar{supertype} and all the parent kinds of @qvar{supertype}.

@item
@qvar{predicate} is bound to a predicate that identifies conditions of type @qvar{condition-kind} or
any of its subtypes.

@item
Each @qvar{accessor} is bound to a procedure that extracts the corresponding field from a condition
of type @qvar{condition-kind}.  The fields of a condition kind are its properties as defined by the
module @library{chicken condition}.
@end itemize
@end deffn


Some usage examples:

@lisp
(define-condition-type &c &condition
  make-c c?
  (x c-x))

(define-condition-type &c1 &c
  make-c1 c1?
  (a c1-a))

(define-condition-type &c2 &c
  make-c2 c2?
  (b c2-b))
@end lisp

@lisp
(define v1 (make-c1 "V1" "a1"))

(c? v1)        @result{} #t
(c1? v1)       @result{} #t
(c2? v1)       @result{} #f
(c-x v1)       @result{} "V1"
(c1-a v1)      @result{} "a1"
@end lisp

@lisp
(define v2 (make-c2 "V2" "b2"))

(c? v2)        @result{} #t
(c1? v2)       @result{} #f
(c2? v2)       @result{} #t
(c-x v2)       @result{} "V2"
(c2-b v2)      @result{} "b2"
@end lisp

@lisp
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        @result{} #t
(c1? v3)       @result{} #t
(c2? v3)       @result{} #t
(c-x v3)       @result{} "V3/1"
(c1-a v3)      @result{} "a3"
(c2-b v3)      @result{} "b3"
@end lisp

@lisp
(define v4 (condition v1 v2))

(c? v4)        @result{} #t
(c1? v4)       @result{} #t
(c2? v4)       @result{} #t
(c-x v4)       @result{} "V1"
(c1-a v4)      @result{} "a1"
(c2-b v4)      @result{} "b2"
@end lisp

@lisp
(define v5 (condition v2 v3))

(c? v5)        @result{} #t
(c1? v5)       @result{} #t
(c2? v5)       @result{} #t
(c-x v5)       @result{} "V2"
(c1-a v5)      @result{} "a3"
(c2-b v5)      @result{} "b2"
@end lisp

@c page
@node conditions types
@section Predefined condition types


Hierarchy of predefined condition types:

@example
&condition
   |
   +-----> &warning
   |
   +-----> &message
   |       &irritants
   |       &who
   |
   +-----> &serious
              |
              +-----> &error
              |
              +-----> &violation
                         |
                         +-----> &assertion
                         |
                         +-----> &non-continuable
                         |
                         +-----> &implementation-restriction
                         |
                         +-----> &lexical
                         |
                         +-----> &syntax
                         |
                          -----> &undefined
@end example


@tindex &message
@deffn {Condition Kind} {&message}
@deffnx Function make-message-condition @var{message}
@deffnx Function message-condition? @var{obj}
@deffnx Function condition-message @var{condition}
This condition type could be defined by:

@example
(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))
@end example

It carries a message further describing the nature of the condition to
humans.
@end deffn


@tindex &warning
@deffn {Condition Kind} {&warning}
@deffnx Function make-warning
@deffnx Function warning? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &warning &condition
  make-warning warning?)
@end example

This type describes conditions that do not, in principle, prohibit
immediate continued execution of the program, but may interfere with the
program's execution later.
@end deffn


@tindex &serious
@deffn {Condition Kind} {&serious}
@deffnx Function make-serious-condition
@deffnx Function serious-condition? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &serious &condition
  make-serious-condition serious-condition?)
@end example

This type describes conditions serious enough that they cannot safely be
ignored.  This condition type is primarily intended as a supertype of
other condition types.
@end deffn


@tindex &error
@deffn {Condition Kind} {&error}
@deffnx Function make-error
@deffnx Function error? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &error &serious
  make-error error?)
@end example

This type describes errors, typically caused by something that has gone
wrong in the interaction of the program with the external world or the
user.
@end deffn


@tindex &violation
@deffn {Condition Kind} {&violation}
@deffnx Function make-violation
@deffnx Function violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &violation &serious
  make-violation violation?)
@end example

This type describes violations of the language standard or a library
standard, typically caused by a programming error.
@end deffn


@tindex &assertion
@deffn {Condition Kind} {&assertion}
@deffnx Function make-assertion-violation
@deffnx Function assertion-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)
@end example

This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
@end deffn


@tindex &irritants
@deffn {Condition Kind} {&irritants}
@deffnx Function make-irritants-condition @var{irritants}
@deffnx Function irritants-condition? @var{obj}
@deffnx Function condition-irritants @var{condition}
This condition type could be defined by:

@example
(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))
@end example

@var{irritants} should be a list of objects.  This condition provides
additional information about a condition, typically the argument list of
a procedure that detected an exception.  Conditions of this type are
created by the procedures @func{error} and @func{assertion-violation}.
@end deffn


@tindex &who
@deffn {Condition Kind} {&who}
@deffnx Function make-who-condition @var{who}
@deffnx Function who-condition? @var{obj}
@deffnx Function condition-who @var{condition}
This condition type could be defined by:

@example
(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))
@end example

@var{who} should be a symbol or string identifying the entity reporting the exception.  Conditions
of this type are created by the @func{error} and @func{assertion-violation} procedures, and the
@func{syntax-violation} procedure.
@end deffn


@tindex &non-continuable
@deffn {Condition Kind} {&non-continuable}
@deffnx Function make-non-continuable-violation
@deffnx Function non-continuable-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)
@end example

This type indicates that an exception handler invoked via @func{raise}
has returned.
@end deffn


@tindex &implementation-restriction
@deffn {Condition Kind} {&implementation-restriction}
@deffnx Function make-implementation-restriction-violation
@deffnx Function implementation-restriction-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &implementation-restriction
    &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)
@end example

This type describes a violation of an implementation restriction allowed
by the specification, such as the absence of representations for NaNs
and infinities.
@end deffn


@tindex &lexical
@deffn {Condition Kind} {&lexical}
@deffnx Function make-lexical-violation
@deffnx Function lexical-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)
@end example

This type describes syntax violations at the level of the datum syntax.
@end deffn


@tindex &syntax
@deffn {Condition Kind} {&syntax}
@deffnx Function make-syntax-violation @var{form} @var{subform}
@deffnx Function syntax-violation? @var{obj}
@deffnx Function syntax-violation-form @var{condition}
@deffnx Function syntax-violation-subform @var{condition}
This condition type could be defined by:

@example
(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))
@end example

This type describes syntax violations.  @var{form} should be the
erroneous syntax object or a datum representing the code of the
erroneous form.  @var{subform} should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be @false{} to indicate the absence of more precise
information.
@end deffn


@tindex &undefined
@deffn {Condition Kind} {&undefined}
@deffnx Function make-undefined-violation
@deffnx Function undefined-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)
@end example

This type describes unbound identifiers in the program.
@end deffn

@c page
@node exceptions
@chapter Handling exceptional--conditions


@cindex Handling exceptional--conditions
@cindex Raising exceptional--conditions
@cindex Exceptional--conditions, raising
@cindex Exceptional--conditions, handling


@value{PACKAGE} allows programs to deal with exceptional situations using two cooperating
facilities: The exception system for raising and handling exceptional situations, and the condition
system for describing these situations.

The exception system allows the program, when it detects an exceptional situation, to pass control
to an exception handler, and to dynamically establish such exception handlers.  Exception handlers
are always invoked with an object describing the exceptional situation.  @value{PACKAGE}'s condition
system provides a predefined taxonomy of such descriptive objects, as well as a facility for
extending the taxonomy, @ref{conditions, Exceptional--condition object}.

The facilities described in this section are built upon a custom exception handler that must be
installed before using any of them.  We can do this in a module with:

@lisp
(module (mine)
    ()
  (import (scheme)
          (mmck exceptional-condition))

  (current-exception-handler default-exception-handler)

  #| end of module |#)
@end lisp

@menu
* exceptions handling::         Exceptions handling.
* exceptions errors::           Raising errors.
* exceptions interop::          Interoperability with @chicken{}.
@end menu

@c page
@node exceptions handling
@section Exceptions handling


This section describes @value{PACKAGE}'s exception--handling and exception--raising constructs
provided by the @library{mmck exceptional-conditions} library.

Exception handlers are one--argument procedures that determine the action the program takes when an
exceptional situation is signalled.  The system implicitly maintains a current exception handler as
part of the dynamic environment of the program.

The program raises an exception by invoking the current exception handler, passing it an object
encapsulating information about the exception.  Any procedure accepting one argument may serve as an
exception handler and any object may be used to represent an exception.

When a program begins its execution, the predefined exception handler:

@itemize
@item
Handles all @condition{serious} conditions by interrupting execution, reporting that an exception
has been raised, and displaying information about the condition object that was provided on the
current value of @func{current-error-port}.  The handler then exits the process with exit status
@code{255}.

@item
Handles all @condition{warning} conditions by reporting that an exception has been raised, and
displaying information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then returns attempting to resume execution.

@item
Handles all the other exceptional conditions by reporting that an exception has been raised, and
displaying information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then returns attempting to resume execution.
@end itemize

When the handler returns:

@itemize
@item
If the exception was raised with @func{raise}, a new exception is raised in a dynamic environment in
which the exception handler interrupts execution, reports that an exception has been raised, and
displays information about the condition object that was provided on the current value of
@func{current-error-port}.  The handler then exits the process with exit status @code{255}.

@item
If the exception was raised with @func{raise-continuable}, execution continues with the continuation
of the call to @func{raise-continuable}.
@end itemize


@defun with-exception-handler @var{handler} @var{thunk}
The argument @var{handler} must be a procedure and should accept one argument.  The argument
@var{thunk} must be a procedure that accepts zero arguments.  The @func{with-exception-handler}
procedure returns the results of invoking @var{thunk}.  @var{handler} is installed as the current
exception handler for the dynamic extent (as determined by @func{dynamic-wind}) of the invocation of
@var{thunk}.
@end defun


@anchor{guard}
@deffn Syntax guard (@qvar{variable} @qvari{cond-clause} @qvarii{cond-clause} @dots{}) @qvaro{body} @qvar{body} @dots{}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @qvar{cond-clause} is as in the specification of the standard syntax @syntax{cond}.  @samp{=>}
and @samp{else} are matched as symbols.

Evaluating a @syntax{guard} form evaluates the @qvar{body} forms with an exception handler that
binds the raised object to @qvar{variable} and within the scope of that binding evaluates the
clauses as if they were the clauses of a @syntax{cond} expression.  That implicit @syntax{cond}
expression is evaluated with the continuation and dynamic environment of the @syntax{guard} form.
If every @qvar{cond-clause}'s @qvar{test} evaluates to @false{} and there is no @code{else} clause,
then @func{raise-continuable} is invoked on the raised object within the dynamic environment of the
original call to @func{raise} or @func{raise-continuable} except that the current exception handler
is that of the @syntax{guard} expression.
@end deffn


@defun raise @var{obj}
Raise a @emph{non--continuable exception} by invoking the current exception handler on @var{obj}.

The handler is called with a continuation whose dynamic environment is that of the call to
@func{raise}, except that the current exception handler is the one that was in place when the
handler being called was installed.  So if the handler itself raises an exception: that exception
will be handled by the upper level handler; no infinite loop will happen by invoking the same
handler again and again.

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (A)
            (escape (cons 'A A)))
        (lambda ()
          (with-exception-handler
              (lambda (B)
                (raise (cons 'B B)))
            (lambda ()
              (with-exception-handler
                  (lambda (C)
                    (raise (cons 'C C)))
                (lambda ()
                  (raise 123)))))))))
@result{} (A B C . 123)
@end lisp

If the handler returns: a non--continuable exception with condition type @condition{non-continuable}
is raised in the same dynamic environment as the handler.

@lisp
(define C
  (call-with-current-continuation
      (lambda (escape)
        (with-exception-handler
            escape
          (lambda ()
            (with-exception-handler
                ;;This handler returns!
                (lambda (obj) obj)
              (lambda ()
                (raise 123))))))))

(condition? C)                  @result{} #t
(serious-condition? C)          @result{} #t
(violation? C)                  @result{} #t
(non-continuable-violation? C)  @result{} #t
(condition-irritants C)         @result{} (123)
@end lisp
@end defun


@defun raise-continuable @var{obj}
Raise a @emph{continuable exception} by invoking the current exception handler on @var{obj}.  The
handler is called with a continuation that is equivalent to the continuation of the call to
@func{raise-continuable}, with these two exceptions:

@enumerate
@item
The current exception handler is the one that was in place when the handler being called was
installed.  So if the handler itself raises an exception: that exception will be handled by the
upper level handler; no infinite loop will happen by invoking the same handler again and again.

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (A)
            (escape (cons 'A A)))
        (lambda ()
          (with-exception-handler
              (lambda (B)
                (raise (cons 'B B)))
            (lambda ()
              (with-exception-handler
                  (lambda (C)
                    (raise (cons 'C C)))
                (lambda ()
                  (raise 123)))))))))
@result{} (A B C . 123)
@end lisp

@item
If the handler being called returns, then it will again become the current exception handler and the
values it returns become the values returned by the call to @func{raise-continuable}.

@lisp
(with-exception-handler
    ;;This handler returns 2 values!
    (lambda (obj)
      (values 'obj obj))
  (lambda ()
    (raise-continuable 123)))
@result{} obj 123
@end lisp
@end enumerate
@end defun

@c page
@node exceptions errors
@section Raising errors


@defun error @var{who} @var{message} @vari{irritant} @dots{}
@defunx assertion-violation @var{who} @var{message} @vari{irritant} @dots{}
@var{who} must be a string or a symbol or @false{}.  @var{message} must be a string.  The
@var{irritant}s are arbitrary objects.

These procedures raise a non--continuable exception.  The @func{error} procedure should be called
when an error has occurred, typically caused by something that has gone wrong in the interaction of
the program with the external world or the user.  The @func{assertion-violation} procedure should be
called when an invalid call to a procedure was made, either passing an invalid number of arguments,
or passing an argument that it is not specified to handle.

The @var{who} argument should describe the procedure or operation that detected the exception.  The
@var{message} argument should describe the exceptional situation.  The @var{irritant}s should be the
arguments to the operation that detected the violation.

The condition object provided with the exception has the following condition types:

@itemize
@item
If @var{who} is not @false{}, the condition has condition type @condition{who}, with @var{who} as
the value of its field.  In that case, @var{who} should be the name of the procedure or entity that
detected the exception.  If it is @false{}, the condition does not have condition type
@condition{who}.

@item
The condition has condition type @condition{message}, with @var{message} as
the value of its field.

@item
The condition has condition type @condition{irritants}, and its field has as
its value a list of the @var{irritant}s.
@end itemize

Moreover, the condition created by @func{error} has condition type
@condition{error}, and the condition created by @func{assertion-violation}
has condition type @condition{assertion}.

@example
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5)         @result{} 120
(fac 4.5)       @error{} exception &assertion
(fac -3)        @error{} exception &assertion
@end example
@end defun


@deffn Syntax assert @meta{expression}
An @func{assert} form is evaluated by evaluating @meta{expression}.  If @meta{expression} returns a
true value, that value is returned from the @func{assert} expression.  If @meta{expression} returns
@false{}, an exception with condition types @condition{assertion} and @condition{message} is raised.
The message provided in the condition object is implementation--dependent.
@end deffn

@c page
@node exceptions interop
@section Interoperability with @chicken{}


There is limited interoperability between the library @library{mmck exceptional-conditions} and the
module @library{chicken condition} bundled with @chicken{}.  We achieve it by setting @chicken{}'s
exception handler to @func{raise-continuable} at the top level:

@lisp
(module (demo)
    ()
  (import (scheme)
          (mmck exceptional-conditions)
          (prefix (chicken condition)
                  chicken::))

  (chicken::current-exception-handler raise-continuable)

  #| end of module |# )
@end lisp

@c ------------------------------------------------------------------------

With this setup we can catch exceptions raised with @func{signal} using @value{PACKAGE}'s
@func{with-exception-handler}:

@lisp
(define C
  (with-exception-handler
      ;;This handler returns.
      (lambda (E) E)
    (lambda ()
      (chicken::signal
       (chicken::make-property-condition 'demo
         'location  'me
         'message   "the message"
         'arguments '(1 2 3))))))

(chicken::get-condition-property C 'demo 'location)
@result{} me

(chicken::get-condition-property C 'demo 'message)
@result{} "the message"

(chicken::get-condition-property C 'demo 'arguments)
@result{} (1 2 3)
@end lisp

@noindent
and we can catch exceptions raised with @func{abort} using @value{PACKAGE}'s
@func{with-exception-handler}:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape
             (list
              (chicken::get-condition-property E 'demo 'location)
              (chicken::get-condition-property E 'demo 'message)
              (chicken::get-condition-property E 'demo 'arguments))))
        (lambda ()
          (chicken::abort
           (chicken::make-property-condition 'demo
             'location  'me
             'message   "the message"
             'arguments '(1 2 3)))))))
@result{} (me "the message" (1 2 3))
@end lisp

@noindent
notice that, due to how @func{abort} is defined, if the handler returns we enter an infinite loop,
exactly like it happens with @chicken{}'s @func{with-exception-handler}.

It is @strong{not possible} to handle exceptions raised with @func{raise} and
@func{raise-continuable} using @chicken{}'s @func{with-exception-handler}; however, we can catch
them and convert them:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (chicken::with-exception-handler
          (lambda (E)
            (escape (error? E)))
        (lambda ()
          (with-exception-handler
              chicken::signal
            (lambda ()
              (raise
               (condition
                 (make-error)
                 (make-who-condition 'me)
                 (make-message-condition "the message")
                 (make-irritants-condition '(1 2 3))))))))))
@result{} #t
@end lisp


@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

The original version of the @rnrs{6} document, and its errata, are available at:

@center @url{http://www.r6rs.org/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
